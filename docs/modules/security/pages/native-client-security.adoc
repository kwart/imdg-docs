= Native Client Security

Hazelcast's Client security includes both authentication and authorization.

== Authentication

The authentication mechanism works the same as cluster member authentication. To implement client authentication, you configure a Credential and one or more LoginModules. The client side also needs a factory object as in member side, e.g., the `ICredentialsFactory` given in the xref:security:cluster-member-security.adoc[Cluster Member Security section] above.

[source,xml]
----
<hazelcast>
    ...
    <security enabled="true">
        <client-login-modules>
            <login-module usage="REQUIRED"
                class-name="com.hazelcast.examples.MyRequiredClientLoginModule">
                <properties>
                    <property name="property3">value3</property>
                </properties>
            </login-module>
            <login-module usage="SUFFICIENT"
                class-name="com.hazelcast.examples.MySufficientClientLoginModule">
                <properties>
                    <property name="property4">value4</property>
                </properties>
            </login-module>
            <login-module usage="OPTIONAL"
                class-name="com.hazelcast.examples.MyOptionalClientLoginModule">
                <properties>
                    <property name="property5">value5</property>
                </properties>
            </login-module>
        </client-login-modules>
    </security>
    ...
</hazelcast>
----

You can define as many as `LoginModules` as you want in the configuration. Those are executed in the order given in configuration. The `usage` attribute has 4 values: 'required', 'requisite', 'sufficient' and 'optional' as defined in `javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag`.

[source,java]
----
ClientConfig clientConfig = new ClientConfig();
clientConfig.setCredentials( new UsernamePasswordCredentials( "dev", "dev-pass" ) );
HazelcastInstance client = HazelcastClient.newHazelcastClient( clientConfig );
----

NOTE: See an implementation and configuration example https://github.com/hazelcast/hazelcast-code-samples/tree/master/enterprise/client-custom-credentials[here].

== Authorization

Hazelcast client authorization is configured by a client permission policy. Hazelcast has a default permission policy implementation that uses permission configurations defined in the Hazelcast security configuration. Default policy permission checks are done against instance types (map, queue, etc.), instance names (map, queue, name, etc.), instance actions (put, read, remove, add, etc.), client endpoint addresses and client principal defined by the Credentials object.

The default permission policy allows to use comma separated names in the `principal`
attribute configuration.

You can define the instance and principal names as wildcards using the `"*"` character.
See the xref:configuration:using-wildcards.adoc[Using Wildcards] section for details.

The endpoint names can use range characters `"-"` and `"*"` as described
in the xref:clusters:network-configuration.adoc#interfaces[Interfaces] section.

[source,xml]
----
<hazelcast>
    ...
    <security enabled="true">
        <client-permissions>
            <!-- Principals 'admin' and 'root' from endpoint '127.0.0.1' have all permissions. -->
            <all-permissions principal="admin,root">
                <endpoints>
                    <endpoint>127.0.0.1</endpoint>
                </endpoints>
            </all-permissions>

            <!-- Principals named 'dev' from all endpoints have 'create', 'destroy',
            'put', 'read' permissions for map named 'myMap'. -->
            <map-permission name="myMap" principal="dev">
                <actions>
                    <action>create</action>
                    <action>destroy</action>
                    <action>put</action>
                    <action>read</action>
                </actions>
            </map-permission>

            <!-- All principals from endpoints '127.0.0.1' or matching to '10.10.*.*'
            have 'put', 'read', 'remove' permissions for map
            whose name matches to 'com.foo.entity.*'. -->
            <map-permission name="com.foo.entity.*">
                <endpoints>
                    <endpoint>10.10.*.*</endpoint>
                    <endpoint>127.0.0.1</endpoint>
                </endpoints>
                <actions>
                    <action>put</action>
                    <action>read</action>
                    <action>remove</action>
                </actions>
            </map-permission>

            <!-- Principals named 'dev' from endpoints matching to either
            '192.168.1.1-100' or '192.168.2.*'
            have 'create', 'add', 'remove' permissions for all queues. -->
            <queue-permission name="*" principal="dev">
                <endpoints>
                    <endpoint>192.168.1.1-100</endpoint>
                    <endpoint>192.168.2.*</endpoint>
                </endpoints>
                <actions>
                    <action>create</action>
                    <action>add</action>
                    <action>remove</action>
                </actions>
            </queue-permission>

           <!-- All principals from all endpoints have transaction permission.-->
           <transaction-permission />
       </client-permissions>
    </security>
    ...
</hazelcast>
----

You can also define your own policy by implementing `com.hazelcast.security.IPermissionPolicy`.

[source,java]
----
package com.hazelcast.security;
/**
 * IPermissionPolicy is used to determine any Subject's
 * permissions to perform a security sensitive Hazelcast operation.
 *
 */
public interface IPermissionPolicy {
  void configure( SecurityConfig securityConfig, Properties properties );

  PermissionCollection getPermissions( Subject subject,
                                       Class<? extends Permission> type );

  void destroy();
}
----

Permission policy implementations can access client-permissions that are in the
configuration by using `SecurityConfig.getClientPermissionConfigs()` when
Hazelcast calls the `configure(SecurityConfig securityConfig, Properties properties)` method.

The `IPermissionPolicy.getPermissions(Subject subject, Class<? extends Permission> type)`
method is used to determine a client request that has been granted permission to
perform a security-sensitive operation.

Permission policy should return a `PermissionCollection` containing permissions
of the given type for the given `Subject`. The Hazelcast access controller calls
`PermissionCollection.implies(Permission)` on returning `PermissionCollection` and
it decides whether the current `Subject` has permission to access the requested resources.

== Permissions

The following is the list of client permissions that can be configured on the member:

* All Permission
+
[source,xml]
----
<all-permissions principal="principal">
    <endpoints>
        ...
    </endpoints>
</all-permissions>
----
+
* Map Permission
+
[source,xml]
----
<map-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</map-permission>
----
+
Actions: all, create, destroy, put, read, remove, lock, intercept, index, listen
+
* Queue Permission
+
[source,xml]
----
<queue-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</queue-permission>
----
+
Actions: all, create, destroy, add, remove, read, listen
+
* Multimap Permission
+
[source,xml]
----
<multimap-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
     </actions>
</multimap-permission>
----
+
Actions: all, create, destroy, put, read, remove, listen, lock
+
* Topic Permission
+
[source,xml]
----
<topic-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</topic-permission>
----
+
Actions: create, destroy, publish, listen
+
* List Permission
+
[source,xml]
----
<list-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</list-permission>
----
+
Actions: all, create, destroy, add, read, remove, listen
+
* Set Permission
+
[source,xml]
----
<set-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</set-permission>
----
+
Actions: all, create, destroy, add, read, remove, listen
+
* Lock Permission
+
[source,xml]
----
<lock-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</lock-permission>
----
+
Actions: all, create, destroy, lock, read
+
* AtomicLong Permission
+
[source,xml]
----
<atomic-long-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</atomic-long-permission>
----
+
Actions: all, create, destroy, read, modify
+
* CountDownLatch Permission
+
[source,xml]
----
<countdown-latch-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</countdown-latch-permission>
----
+
Actions: all, create, destroy, modify, read
+
* IdGenerator Permission
+
[source,xml]
----
<id-generator-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</id-generator-permission>
----
+
Actions: all, create, destroy, modify, read
+
* FlakeIdGenerator Permission
+
[source,xml]
----
<flake-id-generator-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</flake-id-generator-permission>
----
+
Actions: all, create, destroy, modify
+
* Semaphore Permission
+
[source,xml]
----
<semaphore-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</semaphore-permission>
----
+
Actions: all, create, destroy, acquire, release, read
+
* Executor Service Permission
+
[source,xml]
----
<executor-service-permission name="name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</executor-service-permission>
----
+
Actions: all, create, destroy
+
* Transaction Permission
+
[source,xml]
----
<transaction-permission principal="principal">
    <endpoints>
        ...
    </endpoints>
</transaction-permission>
----
+
* Cache Permission
+
[source,xml]
----
<cache-permission name="/hz/cache-name" principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</cache-permission>
----
+
Actions: all, create, destroy, put, read, remove, listen
+
* User Code Deployment Permission
+
[source,xml]
----
<user-code-deployment-permission principal="principal">
    <endpoints>
        ...
    </endpoints>
    <actions>
        ...
    </actions>
</user-code-deployment-permission>
----
+
Actions: all, deploy

NOTE: The name provided in `cache-permission` must be the Hazelcast distributed object name corresponding to the `Cache` as described in xref:jcache:jcache-hazelcast-instance-integration.adoc[JCache - Hazelcast Instance Integration].

=== Handling Permissions When a New Member Joins

By default, the set of permissions defined in the leader member of a cluster is
distributed to the newly joining members, overriding their own permission
configurations, if any. However, you can configure a new member to be joined, so that
it keeps its own set of permissions and even send these to the existing members in
the cluster. This can be done dynamically, i.e., without needing to restart the
cluster, using either one of the following configuration options:

* the `on-join-operation` configuration attribute
* the `setOnJoinPermissionOperation()` method

Using the above, you can choose whether a new member joining to a cluster will
apply the client permissions stored in its own configuration, or use the ones
defined in the cluster. The behaviors that you can specify with the configuration
are `RECEIVE`, `SEND` and `NONE`, which are described after the examples below.

The following are the examples for both approaches on how to use them:

**Declarative Configuration:**

[source,xml]
----
<hazelcast>
    ...
    <security enabled="true">
        <client-permissions on-join-operation="SEND">
            <!-- ... -->
        </client-permissions>
    </security>
    ...
</hazelcast>
----

**Programmatic Configuration:**

[source,java]
----
Config config = new Config();
config.getSecurityConfig()
    .setEnabled(true)
    .setOnJoinPermissionOperation(OnJoinPermissionOperationName.SEND);
----

The behaviors are explained below:

* `RECEIVE`: Applies the permissions from the leader member in the
cluster before join. This is the default value.
* `SEND`: Doesn't apply the permissions from the leader member before join.
If the security is enabled, then it refreshes or replaces the cluster wide
permissions with the ones in the new member after the join is complete.
This option is suitable for the scenarios where you need to replace the
cluster wide permissions without restarting the cluster.
* `NONE`: Neither applies pre-join permissions, nor sends the local permissions
to the other members. It means that the new member does not send its own
permission definitions to the cluster, but keeps them when it joins. However,
after the join, when you update the permissions in the other cluster members,
those updates are also sent to the newly joining member. Therefore, this option
is suitable for the scenarios where you need to elevate privileges temporarily
on a single member (preferably a xref:management:cluster-utilities.adoc#enabling-lite-members[lite member]) for a
limited time period. The clients which want to use these temporary permissions
have to access the cluster through this single new member, meaning that you need
to disable xref:clients:java.adoc#setting-smart-routing[smart routing] for such clients.
+
Note that, the `create` and `destroy` permissions will not work when using
the `NONE` option, since the distributed objects need to be created/destroyed on all the members.
+
The following is an example for a scenario where `NONE` is used:
+
[source,java]
----
// temporary member, in the below case a lite member
Config config = new Config().setLiteMember(true);
PermissionConfig allPermission = new PermissionConfig(PermissionType.ALL, "*", null);
config.getSecurityConfig()
  .setEnabled(true)
  .setOnJoinPermissionOperation(OnJoinPermissionOperationName.NONE)
  .addClientPermissionConfig(allPermission);
HazelcastInstance hzLite = Hazelcast.newHazelcastInstance(config);

// temporary client connecting only to the lite member
String memberAddr = ...;
ClientConfig clientConfig = new ClientConfig();
clientConfig.getNetworkConfig().setSmartRouting(false)
  .addAddress(memberAddr);
HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);

// do operations with escalated privileges:
client.getMap("protectedConfig").put("master.resolution", "1920");

// shutdown the client and lite member
client.shutdown();
hzLite.shutdown();
----